<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tardis.simulation.base &mdash; tardis</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/tardis_logo.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href="../../../_static/tardis.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> tardis
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/quickstart.html">Quickstart for TARDIS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Input/Output</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../io/configuration/index.html">Configuration (Required Input)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/optional/index.html">Optional Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/visualization/index.html">Visualization Tools &amp; Widgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/output/index.html">Additional Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/grid/TardisGridTutorial.html">TARDIS Grid Tutorial</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Physics Walkthrough</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../physics/setup/index.html">Setting Up the Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics/montecarlo/index.html">Monte Carlo Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics/est_and_conv/index.html">Estimators and Convergence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics/spectrum/index.html">Spectrum Generation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Research with TARDIS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../research/index.html">Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Team &amp; Credits</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../team_and_governance/index.html">Team and Governance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits &amp; Publication Policies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../CODE_OF_CONDUCT.html">Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sponsors.html">Sponsors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing to TARDIS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../CONTRIBUTING.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development/index.html">Developer Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../CHANGELOG.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../roadmap.html">Development Roadmap</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">tardis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../zreferences.html">TARDIS Papers and useful References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Outdated</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../outdated/index.html">Outdated Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">tardis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>tardis.simulation.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tardis.simulation.base</h1><div class="highlight"><pre>
<span></span>import time
import logging
import numpy as np
import pandas as pd
from astropy import units as u, constants as const
from collections import OrderedDict
from tardis import model

from tardis.montecarlo import MontecarloRunner
from tardis.model import Radial1DModel
from tardis.plasma.standard_plasmas import assemble_plasma
from tardis.io.util import HDFWriterMixin
from tardis.io.config_reader import ConfigurationError
from tardis.util.base import is_notebook
from tardis.montecarlo import montecarlo_configuration as mc_config_module
from tardis.visualization import ConvergencePlots
from IPython.display import display

# Adding logging support
logger = logging.getLogger(__name__)


<div class="viewcode-block" id="PlasmaStateStorerMixin"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.PlasmaStateStorerMixin">[docs]</a>class PlasmaStateStorerMixin(object):
    &quot;&quot;&quot;Mixin class to provide the capability to the simulation object of
    storing plasma information and the inner boundary temperature during each
    MC iteration.

    Currently, storage for the dilution factor, the radiation temperature and
    the electron density in each cell is provided. Additionally, the
    temperature at the inner boundary is saved.
    &quot;&quot;&quot;

    def __init__(self, iterations, no_of_shells):

        self.iterations_w = np.zeros((iterations, no_of_shells))
        self.iterations_t_rad = np.zeros((iterations, no_of_shells)) * u.K
        self.iterations_electron_densities = np.zeros(
            (iterations, no_of_shells)
        )
        self.iterations_t_inner = np.zeros(iterations) * u.K

<div class="viewcode-block" id="PlasmaStateStorerMixin.store_plasma_state"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.PlasmaStateStorerMixin.store_plasma_state">[docs]</a>    def store_plasma_state(self, i, w, t_rad, electron_densities, t_inner):
        &quot;&quot;&quot;Store current plasma information and inner boundary temperature
        used in iterated i.

        Parameters
        ----------
        i : int
            current iteration index (0 for the first)
        w : np.ndarray
            dilution factor
        t_rad : astropy.units.Quantity
            radiation temperature
        electron_densities : np.ndarray
            electron density
        t_inner : astropy.units.Quantity
            temperature of inner boundary
        &quot;&quot;&quot;
        self.iterations_w[i, :] = w
        self.iterations_t_rad[i, :] = t_rad
        self.iterations_electron_densities[i, :] = electron_densities.values
        self.iterations_t_inner[i] = t_inner</div>

<div class="viewcode-block" id="PlasmaStateStorerMixin.reshape_plasma_state_store"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.PlasmaStateStorerMixin.reshape_plasma_state_store">[docs]</a>    def reshape_plasma_state_store(self, executed_iterations):
        &quot;&quot;&quot;Reshapes the storage arrays in case convergence was reached before
        all specified iterations were executed.

        Parameters
        ----------
        executed_iterations : int
            iteration index, i.e. number of iterations executed minus one!
        &quot;&quot;&quot;
        self.iterations_w = self.iterations_w[: executed_iterations + 1, :]
        self.iterations_t_rad = self.iterations_t_rad[
            : executed_iterations + 1, :
        ]
        self.iterations_electron_densities = self.iterations_electron_densities[
            : executed_iterations + 1, :
        ]
        self.iterations_t_inner = self.iterations_t_inner[
            : executed_iterations + 1
        ]</div></div>


<div class="viewcode-block" id="Simulation"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation">[docs]</a>class Simulation(PlasmaStateStorerMixin, HDFWriterMixin):
    &quot;&quot;&quot;A composite object containing all the required information for a
    simulation.

    Parameters
    ----------
    converged : bool
    iterations : int
    model : tardis.model.Radial1DModel
    plasma : tardis.plasma.BasePlasma
    runner : tardis.montecarlo.MontecarloRunner
    no_of_packets : int
    last_no_of_packets : int
    no_of_virtual_packets : int
    luminosity_nu_start : astropy.units.Quantity
    luminosity_nu_end : astropy.units.Quantity
    luminosity_requested : astropy.units.Quantity
    cplots_kwargs: dict
    nthreads : int
        The number of threads to run montecarlo with

        .. note:: TARDIS must be built with OpenMP support in order for ``nthreads`` to have effect.

    &quot;&quot;&quot;

    hdf_properties = [
        &quot;model&quot;,
        &quot;plasma&quot;,
        &quot;runner&quot;,
        &quot;iterations_w&quot;,
        &quot;iterations_t_rad&quot;,
        &quot;iterations_electron_densities&quot;,
        &quot;iterations_t_inner&quot;,
    ]
    hdf_name = &quot;simulation&quot;

    def __init__(
        self,
        iterations,
        model,
        plasma,
        runner,
        no_of_packets,
        no_of_virtual_packets,
        luminosity_nu_start,
        luminosity_nu_end,
        last_no_of_packets,
        luminosity_requested,
        convergence_strategy,
        nthreads,
        show_cplots,
        cplots_kwargs,
    ):

        super(Simulation, self).__init__(iterations, model.no_of_shells)

        self.converged = False
        self.iterations = iterations
        self.iterations_executed = 0
        self.model = model
        self.plasma = plasma
        self.runner = runner
        self.no_of_packets = no_of_packets
        self.last_no_of_packets = last_no_of_packets
        self.no_of_virtual_packets = no_of_virtual_packets
        self.luminosity_nu_start = luminosity_nu_start
        self.luminosity_nu_end = luminosity_nu_end
        self.luminosity_requested = luminosity_requested
        self.nthreads = nthreads

        if convergence_strategy.type in (&quot;damped&quot;):
            self.convergence_strategy = convergence_strategy
            self.converged = False
            self.consecutive_converges_count = 0
        elif convergence_strategy.type in (&quot;custom&quot;):
            raise NotImplementedError(
                &quot;Convergence strategy type is custom; &quot;
                &quot;you need to implement your specific treatment!&quot;
            )
        else:
            raise ValueError(
                f&quot;Convergence strategy type is &quot;
                f&quot;not damped or custom &quot;
                f&quot;- input is {convergence_strategy.type}&quot;
            )

        if show_cplots:
            self.cplots = ConvergencePlots(
                iterations=self.iterations, **cplots_kwargs
            )

            if &quot;export_cplots&quot; in cplots_kwargs:
                if not isinstance(cplots_kwargs[&quot;export_cplots&quot;], bool):
                    raise TypeError(&quot;Expected bool in export_cplots argument&quot;)
                self.export_cplots = cplots_kwargs[&quot;export_cplots&quot;]
            else:
                self.export_cplots = False

        self._callbacks = OrderedDict()
        self._cb_next_id = 0

<div class="viewcode-block" id="Simulation.estimate_t_inner"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.estimate_t_inner">[docs]</a>    def estimate_t_inner(
        self, input_t_inner, luminosity_requested, t_inner_update_exponent=-0.5
    ):
        emitted_luminosity = self.runner.calculate_emitted_luminosity(
            self.luminosity_nu_start, self.luminosity_nu_end
        )

        luminosity_ratios = (
            (emitted_luminosity / luminosity_requested).to(1).value
        )

        return input_t_inner * luminosity_ratios ** t_inner_update_exponent</div>

<div class="viewcode-block" id="Simulation.damped_converge"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.damped_converge">[docs]</a>    @staticmethod
    def damped_converge(value, estimated_value, damping_factor):
        # FIXME: Should convergence strategy have its own class containing this
        # as a method
        return value + damping_factor * (estimated_value - value)</div>

    def _get_convergence_status(
        self, t_rad, w, t_inner, estimated_t_rad, estimated_w, estimated_t_inner
    ):
        # FIXME: Move the convergence checking in its own class.
        no_of_shells = self.model.no_of_shells

        convergence_t_rad = (
            abs(t_rad - estimated_t_rad) / estimated_t_rad
        ).value
        convergence_w = abs(w - estimated_w) / estimated_w
        convergence_t_inner = (
            abs(t_inner - estimated_t_inner) / estimated_t_inner
        ).value

        fraction_t_rad_converged = (
            np.count_nonzero(
                convergence_t_rad &lt; self.convergence_strategy.t_rad.threshold
            )
            / no_of_shells
        )

        t_rad_converged = (
            fraction_t_rad_converged &gt; self.convergence_strategy.fraction
        )

        fraction_w_converged = (
            np.count_nonzero(
                convergence_w &lt; self.convergence_strategy.w.threshold
            )
            / no_of_shells
        )

        w_converged = fraction_w_converged &gt; self.convergence_strategy.fraction

        t_inner_converged = (
            convergence_t_inner &lt; self.convergence_strategy.t_inner.threshold
        )

        if np.all([t_rad_converged, w_converged, t_inner_converged]):
            hold_iterations = self.convergence_strategy.hold_iterations
            self.consecutive_converges_count += 1
            logger.info(
                f&quot;Iteration converged {self.consecutive_converges_count:d}/{(hold_iterations + 1):d} consecutive &quot;
                f&quot;times.&quot;
            )
            # If an iteration has converged, require hold_iterations more
            # iterations to converge before we conclude that the Simulation
            # is converged.
            return self.consecutive_converges_count == hold_iterations + 1
        else:
            self.consecutive_converges_count = 0
            return False

<div class="viewcode-block" id="Simulation.advance_state"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.advance_state">[docs]</a>    def advance_state(self):
        &quot;&quot;&quot;
        Advances the state of the model and the plasma for the next
        iteration of the simulation. Returns True if the convergence criteria
        are met, else False.

        Returns
        -------
            converged : bool
        &quot;&quot;&quot;
        (
            estimated_t_rad,
            estimated_w,
        ) = self.runner.calculate_radiationfield_properties()
        estimated_t_inner = self.estimate_t_inner(
            self.model.t_inner,
            self.luminosity_requested,
            t_inner_update_exponent=self.convergence_strategy.t_inner_update_exponent,
        )

        converged = self._get_convergence_status(
            self.model.t_rad,
            self.model.w,
            self.model.t_inner,
            estimated_t_rad,
            estimated_w,
            estimated_t_inner,
        )

        # calculate_next_plasma_state equivalent
        # FIXME: Should convergence strategy have its own class?
        next_t_rad = self.damped_converge(
            self.model.t_rad,
            estimated_t_rad,
            self.convergence_strategy.t_rad.damping_constant,
        )
        next_w = self.damped_converge(
            self.model.w,
            estimated_w,
            self.convergence_strategy.w.damping_constant,
        )
        if (
            self.iterations_executed + 1
        ) % self.convergence_strategy.lock_t_inner_cycles == 0:
            next_t_inner = self.damped_converge(
                self.model.t_inner,
                estimated_t_inner,
                self.convergence_strategy.t_inner.damping_constant,
            )
        else:
            next_t_inner = self.model.t_inner

        if hasattr(self, &quot;cplots&quot;):
            self.cplots.fetch_data(
                name=&quot;t_inner&quot;,
                value=self.model.t_inner.value,
                item_type=&quot;value&quot;,
            )
            self.cplots.fetch_data(
                name=&quot;t_rad&quot;, value=self.model.t_rad, item_type=&quot;iterable&quot;
            )
            self.cplots.fetch_data(
                name=&quot;w&quot;, value=self.model.w, item_type=&quot;iterable&quot;
            )
            self.cplots.fetch_data(
                name=&quot;velocity&quot;, value=self.model.velocity, item_type=&quot;iterable&quot;
            )

        self.log_plasma_state(
            self.model.t_rad,
            self.model.w,
            self.model.t_inner,
            next_t_rad,
            next_w,
            next_t_inner,
        )
        self.model.t_rad = next_t_rad
        self.model.w = next_w
        self.model.t_inner = next_t_inner

        # model.calculate_j_blues() equivalent
        # model.update_plasmas() equivalent
        # Bad test to see if this is a nlte run
        if &quot;nlte_data&quot; in self.plasma.outputs_dict:
            self.plasma.store_previous_properties()

        update_properties = dict(t_rad=self.model.t_rad, w=self.model.w)
        # A check to see if the plasma is set with JBluesDetailed, in which
        # case it needs some extra kwargs.
        if &quot;j_blue_estimator&quot; in self.plasma.outputs_dict:
            update_properties.update(
                t_inner=next_t_inner,
                j_blue_estimator=self.runner.j_blue_estimator,
            )

        self.plasma.update(**update_properties)

        return converged</div>

<div class="viewcode-block" id="Simulation.iterate"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.iterate">[docs]</a>    def iterate(self, no_of_packets, no_of_virtual_packets=0, last_run=False):
        logger.info(
            f&quot;Starting iteration {(self.iterations_executed + 1):d} of {self.iterations:d}&quot;
        )
        self.runner.run(
            self.model,
            self.plasma,
            no_of_packets,
            no_of_virtual_packets=no_of_virtual_packets,
            nthreads=self.nthreads,
            last_run=last_run,
            iteration=self.iterations_executed,
        )
        output_energy = self.runner.output_energy
        if np.sum(output_energy &lt; 0) == len(output_energy):
            logger.critical(&quot;No r-packet escaped through the outer boundary.&quot;)

        emitted_luminosity = self.runner.calculate_emitted_luminosity(
            self.luminosity_nu_start, self.luminosity_nu_end
        )
        reabsorbed_luminosity = self.runner.calculate_reabsorbed_luminosity(
            self.luminosity_nu_start, self.luminosity_nu_end
        )
        if hasattr(self, &quot;cplots&quot;):
            self.cplots.fetch_data(
                name=&quot;Emitted&quot;,
                value=emitted_luminosity.value,
                item_type=&quot;value&quot;,
            )
            self.cplots.fetch_data(
                name=&quot;Absorbed&quot;,
                value=reabsorbed_luminosity.value,
                item_type=&quot;value&quot;,
            )
            self.cplots.fetch_data(
                name=&quot;Requested&quot;,
                value=self.luminosity_requested.value,
                item_type=&quot;value&quot;,
            )

        self.log_run_results(emitted_luminosity, reabsorbed_luminosity)
        self.iterations_executed += 1</div>

<div class="viewcode-block" id="Simulation.run"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.run">[docs]</a>    def run(self):
        &quot;&quot;&quot;
        run the simulation
        &quot;&quot;&quot;

        start_time = time.time()
        while self.iterations_executed &lt; self.iterations - 1:
            self.store_plasma_state(
                self.iterations_executed,
                self.model.w,
                self.model.t_rad,
                self.plasma.electron_densities,
                self.model.t_inner,
            )
            self.iterate(self.no_of_packets)
            self.converged = self.advance_state()
            if hasattr(self, &quot;cplots&quot;):
                self.cplots.update()
            self._call_back()
            if self.converged:
                if self.convergence_strategy.stop_if_converged:
                    break
        # Last iteration
        self.store_plasma_state(
            self.iterations_executed,
            self.model.w,
            self.model.t_rad,
            self.plasma.electron_densities,
            self.model.t_inner,
        )
        self.iterate(
            self.last_no_of_packets, self.no_of_virtual_packets, last_run=True
        )

        self.reshape_plasma_state_store(self.iterations_executed)
        if hasattr(self, &quot;cplots&quot;):
            self.cplots.fetch_data(
                name=&quot;t_inner&quot;,
                value=self.model.t_inner.value,
                item_type=&quot;value&quot;,
            )
            self.cplots.update(export_cplots=self.export_cplots, last=True)

        logger.info(
            f&quot;Simulation finished in {self.iterations_executed:d} iterations &quot;
            f&quot;Simulation took {(time.time() - start_time):.2f} s\n&quot;
        )
        self._call_back()</div>

<div class="viewcode-block" id="Simulation.log_plasma_state"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.log_plasma_state">[docs]</a>    def log_plasma_state(
        self,
        t_rad,
        w,
        t_inner,
        next_t_rad,
        next_w,
        next_t_inner,
        log_sampling=5,
    ):
        &quot;&quot;&quot;
        Logging the change of the plasma state

        Parameters
        ----------
        t_rad : astropy.units.Quanity
            current t_rad
        w : astropy.units.Quanity
            current w
        next_t_rad : astropy.units.Quanity
            next t_rad
        next_w : astropy.units.Quanity
            next_w
        log_sampling : int
            the n-th shells to be plotted

        Returns
        -------
        &quot;&quot;&quot;

        plasma_state_log = pd.DataFrame(
            index=np.arange(len(t_rad)),
            columns=[&quot;t_rad&quot;, &quot;next_t_rad&quot;, &quot;w&quot;, &quot;next_w&quot;],
        )
        plasma_state_log[&quot;t_rad&quot;] = t_rad
        plasma_state_log[&quot;next_t_rad&quot;] = next_t_rad
        plasma_state_log[&quot;w&quot;] = w
        plasma_state_log[&quot;next_w&quot;] = next_w
        plasma_state_log.columns.name = &quot;Shell No.&quot;

        if is_notebook():
            logger.info(&quot;Plasma stratification:&quot;)

            # Displaying the DataFrame only when the logging level is NOTSET, DEBUG or INFO
            if logger.level &lt;= logging.INFO:
                if not logger.filters:
                    display(
                        plasma_state_log.iloc[::log_sampling].style.format(
                            &quot;{:.3g}&quot;
                        )
                    )
                elif logger.filters[0].log_level == 20:
                    display(
                        plasma_state_log.iloc[::log_sampling].style.format(
                            &quot;{:.3g}&quot;
                        )
                    )
        else:
            output_df = &quot;&quot;
            plasma_output = plasma_state_log.iloc[::log_sampling].to_string(
                float_format=lambda x: &quot;{:.3g}&quot;.format(x),
                justify=&quot;center&quot;,
            )
            for value in plasma_output.split(&quot;\n&quot;):
                output_df = output_df + &quot;\t{}\n&quot;.format(value)
            logger.info(&quot;Plasma stratification:&quot;)
            logger.info(f&quot;\n{output_df}&quot;)

        logger.info(
            f&quot;Current t_inner = {t_inner:.3f}\n\tExpected t_inner for next iteration = {next_t_inner:.3f}\n&quot;
        )</div>

<div class="viewcode-block" id="Simulation.log_run_results"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.log_run_results">[docs]</a>    def log_run_results(self, emitted_luminosity, absorbed_luminosity):
        logger.info(
            f&quot;Luminosity emitted   = {emitted_luminosity:.3e}\n&quot;
            f&quot;\tLuminosity absorbed  = {absorbed_luminosity:.3e}\n&quot;
            f&quot;\tLuminosity requested = {self.luminosity_requested:.3e}\n&quot;
        )</div>

    def _call_back(self):
        for cb, args in self._callbacks.values():
            cb(self, *args)

<div class="viewcode-block" id="Simulation.add_callback"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.add_callback">[docs]</a>    def add_callback(self, cb_func, *args):
        &quot;&quot;&quot;
        Add a function which will be called
        after every iteration.

        The cb_func signature must look like:
        cb_func(simulation, extra_arg1, ...)

        Parameters
        ----------
        cb_func : callable
            The callback function
        arg1 :
            The first additional arguments passed to the callable function
        ...

        Returns
        -------
        : int
            The callback ID
        &quot;&quot;&quot;
        cb_id = self._cb_next_id
        self._callbacks[cb_id] = (cb_func, args)
        self._cb_next_id += 1
        return cb_id</div>

<div class="viewcode-block" id="Simulation.remove_callback"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.remove_callback">[docs]</a>    def remove_callback(self, id):
        &quot;&quot;&quot;
        Remove the callback with a specific ID (which was returned by
        add_callback)

        Parameters
        ----------
        id : int
            The callback ID

        Returns
        -------
        : True if the callback was successfully removed.
        &quot;&quot;&quot;
        try:
            del self._callbacks[id]
            return True
        except KeyError:
            logger.debug(f&quot;Call Back was not found in {self._callbacks.keys()}&quot;)
            return False</div>

<div class="viewcode-block" id="Simulation.from_config"><a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.from_config">[docs]</a>    @classmethod
    def from_config(
        cls,
        config,
        packet_source=None,
        virtual_packet_logging=False,
        show_cplots=True,
        **kwargs,
    ):
        &quot;&quot;&quot;
        Create a new Simulation instance from a Configuration object.

        Parameters
        ----------
        config : tardis.io.config_reader.Configuration

        **kwargs
            Allow overriding some structures, such as model, plasma, atomic data
            and the runner, instead of creating them from the configuration
            object.

        Returns
        -------
        Simulation
        &quot;&quot;&quot;
        # Allow overriding some config structures. This is useful in some
        # unit tests, and could be extended in all the from_config classmethods.
        if &quot;model&quot; in kwargs:
            model = kwargs[&quot;model&quot;]
        else:
            if hasattr(config, &quot;csvy_model&quot;):
                model = Radial1DModel.from_csvy(config)
            else:
                model = Radial1DModel.from_config(config)
        if &quot;plasma&quot; in kwargs:
            plasma = kwargs[&quot;plasma&quot;]
        else:
            plasma = assemble_plasma(
                config, model, atom_data=kwargs.get(&quot;atom_data&quot;, None)
            )
        if &quot;runner&quot; in kwargs:
            if packet_source is not None:
                raise ConfigurationError(
                    &quot;Cannot specify packet_source and runner at the same time.&quot;
                )
            runner = kwargs[&quot;runner&quot;]
        else:
            runner = MontecarloRunner.from_config(
                config,
                packet_source=packet_source,
                virtual_packet_logging=virtual_packet_logging,
            )

        cplots_config_options = [
            &quot;plasma_plot_config&quot;,
            &quot;t_inner_luminosities_config&quot;,
            &quot;plasma_cmap&quot;,
            &quot;t_inner_luminosities_colors&quot;,
            &quot;export_cplots&quot;,
        ]
        cplots_kwargs = {}
        for item in set(cplots_config_options).intersection(kwargs.keys()):
            cplots_kwargs[item] = kwargs[item]

        luminosity_nu_start = config.supernova.luminosity_wavelength_end.to(
            u.Hz, u.spectral()
        )

        if u.isclose(
            config.supernova.luminosity_wavelength_start, 0 * u.angstrom
        ):
            luminosity_nu_end = np.inf * u.Hz
        else:
            luminosity_nu_end = (
                const.c / config.supernova.luminosity_wavelength_start
            ).to(u.Hz)

        last_no_of_packets = config.montecarlo.last_no_of_packets
        if last_no_of_packets is None or last_no_of_packets &lt; 0:
            last_no_of_packets = config.montecarlo.no_of_packets
        last_no_of_packets = int(last_no_of_packets)

        return cls(
            iterations=config.montecarlo.iterations,
            model=model,
            plasma=plasma,
            runner=runner,
            show_cplots=show_cplots,
            no_of_packets=int(config.montecarlo.no_of_packets),
            no_of_virtual_packets=int(config.montecarlo.no_of_virtual_packets),
            luminosity_nu_start=luminosity_nu_start,
            luminosity_nu_end=luminosity_nu_end,
            last_no_of_packets=last_no_of_packets,
            luminosity_requested=config.supernova.luminosity_requested.cgs,
            convergence_strategy=config.montecarlo.convergence_strategy,
            nthreads=config.montecarlo.nthreads,
            cplots_kwargs=cplots_kwargs,
        )</div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2021, TARDIS Collaboration.
      <span class="lastupdated">Last updated on 26 Sep 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>